\chapter{Basic usage}

\needspace{6\baselineskip}
To use a minimal feature set of the Xenon library, you'll need the following software packages:
\begin{enumerate}
\item{\textit{Git}\index{Git}, a version management system;}
\item{\textit{Java}\index{Java}, a general purpose programming language;}
\end{enumerate}


The following sections describe the necessary steps in more detail.




\section{Installing Git}
\index{Installing Git}

Open a terminal (default keybinding Ctrl + Alt + t). The shell should be Bash\index{Bash}. You can check this with:
\Needspace{5\baselineskip}
\begin{lstlisting}[style=basic,style=bash]
echo $0
\end{lstlisting} % fix syntax highlighting by inserting an extra dollar sign $
which should return \texttt{/bin/bash}.


\Needspace{5\baselineskip}
Now install \texttt{git}\index{Git!git@\texttt{git}} if you don't have it already:
\begin{lstlisting}[style=basic,style=bash]
sudo apt-get install git
\end{lstlisting}

After the install completes, we need to get a copy of the examples. We will use \texttt{git} to do so. Change into the directory that you want to end up containing the top-level repository directory. I want to put the Xenon examples in my home directory, so for me that means:
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}
\end{lstlisting} % fix syntax highlighting by inserting an extra dollar sign $

\Needspace{5\baselineskip}
Then clone the Xenon-examples repository into the current directory:
\begin{lstlisting}[style=basic,style=bash]
git clone https://github.com/NLeSC/Xenon-examples.git
\end{lstlisting}
This will create a directory \texttt{\mytilde{}/Xenon-examples} that contains the source code of the Xenon examples.






\section{Installing Java}
\index{Installing Java}

Xenon is a Java library, therefore it needs Java in order to run. Java comes in different versions identified by a name and a number. The labeling is somewhat confusing\footnote{See for example \url{http://stackoverflow.com/questions/2411288/java-versioning-and-terminology-1-6-vs-6-0-openjdk-vs-sun}}. This is partly because Java was first developed by Sun Microsystems (which was later bought by Oracle Corporation), while an open-source implementation is also available (it comes standard with many Linuxes). Furthermore, there are different flavors for each version, each flavor having different capabilities. For example, if you just want to \textit{run} Java applications, you need the JRE\index{JRE} (Java Runtime Environment\index{Java Runtime Environment}); if you also want to \textit{develop} Java software, you'll need either an SDK\index{SDK} (Software Development Kit\index{Java Software Development Kit}) from Sun/Oracle, or a JDK\index{JDK} (Java Development Kit\index{Java Development Kit}) if you are using the open-source variant.

Check if you have Java and if so, what version you have:
\begin{lstlisting}[style=basic,style=bash]
java -version
\end{lstlisting}
That should produce something like:
\begin{lstlisting}[style=basic,style=bash]
java version "1.7.0_79"
OpenJDK Runtime Environment (IcedTea 2.5.6) (7u79-2.5.6-0ubuntu1.14.04.1)
OpenJDK 64-Bit Server VM (build 24.79-b02, mixed mode)
\end{lstlisting}
Note that `Java version 1.7' is often referred to as `Java 7'.

If you don't have Java yet, install it with:
\begin{lstlisting}[style=basic,style=bash]
sudo apt-get install default-jdk
\end{lstlisting}
this will install the open-source variant of Java (`OpenJDK'\index{Java!OpenJDK}\index{OpenJDK}).












\section{Building with \texttt{gradlew}}

To check if everything works, we first need to build the example from source and then run the example from the command line.

At this point, \mytilde/\url{Xenon-examples} only contains files directly related to the source code of the example files. However, in order to build and run the examples successfully, we'll need a few more things. Naturally, we'll need a copy of the Xenon library, but the Xenon library in turn also has dependencies that need to be resolved. Because the process of fitting together the right libraries is quite a lot of work, we have automated it. For this, we use the build automation tool\index{build automation}\index{build tool} Gradle\index{Gradle}\footnote{\url{http://gradle.org/}}. Interestingly, you do not need to install Gradle for it to work (although you do need Java). This is because the Xenon-examples repository already includes a script called \texttt{gradlew}, which will download a predefined version of the Gradle program upon execution. The advantage of using \texttt{gradlew} for this is that the resulting build setup will be exactly the same as what the developers use, thus avoiding any bugs that stem solely from build configuration differences.

The \texttt{gradlew} script can be run with arguments. For example, running
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon-examples
./gradlew dependencies
\end{lstlisting} % dummy $
prints a list of the dependencies (of which there are quite many), and

\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
./gradlew clean
\end{lstlisting} % dummy $
cleans up the files pertaining to any previous builds.

\texttt{dependencies} and \texttt{clean} are referred to as `Gradle tasks', `build tasks' or just `tasks'\index{Gradle!tasks}. Tasks are defined in a so-called build file\index{Gradle!build file} called `build.gradle'. To get an overview of all available tasks you could read through `build.gradle', or you could simply run:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
./gradlew tasks
\end{lstlisting} % dummy $

or

\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
./gradlew tasks --all
\end{lstlisting} % dummy $

If you run \texttt{./gradlew tasks}, you'll see a line at the top that says that the default task is called \texttt{shadowJar}\index{shadowJar@\texttt{shadowJar}}\footnote{\url{https://github.com/johnrengelman/shadow}}. \texttt{shadowJar} bundles any and all dependencies into one large jar, sometimes referred to as a `fat jar'\index{fat jar}. Once you figure out what to put in it, using a fat jar makes deployment more robust against forgotten-dependency errors. Lucky for you, someone has already figured out how to make the fat jar, and has even written it down in a file that Gradle can understand.

Run \texttt{./gradlew} (without any arguments) to start the default task. The following things will happen:
\begin{enumerate}
\item{the correct version of Gradle will be downloaded;}
\item{the Xenon library will be downloaded;}
\item{any dependencies that the Xenon library has will be downloaded;}
\item{all of that will then be compiled;}
\item{a fat jar will be created.}
\end{enumerate}



\section{Running an example}

So at this point we have compiled the necessary Java classes; now we need to figure out how to run them.

The general syntax for running compiled Java programs from the command line\index{Java!from the command line} is as follows:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
java (*@\textit{<fully qualified classname>}@*)
\end{lstlisting}
We will use the \texttt{DirectoryListing} example from the \url{nl.esciencecenter.xenon.examples.files} package. As the name implies, it lists the directory contents of a given directory. The fully qualified classname for our example is \url{nl.esciencecenter.xenon.examples.files.DirectoryListing}, but if you try to run
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon-examples
java nl.esciencecenter.xenon.examples.files.DirectoryListing
\end{lstlisting} % dummy $
you will get the error below:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
Error: Could not find or load main class \
nl.esciencecenter.xenon.examples.files.DirectoryListing
\end{lstlisting}

This is because the \url{java} executable tries to locate our class \url{nl.esciencecenter.xenon.examples.files.DirectoryListing}, but we haven't told \url{java} where to look for it. We can resolve that by specifying a list of one or more directories using \texttt{java}'s classpath option \texttt{-cp}\index{Java!from the command line!classpath}\index{Java!from the command line!-cp@\texttt{-cp}}.

Directory names can be passed to \texttt{java} as a colon-separated list, in which directory names can be relative to the current directory. Furthermore, the syntax is slightly different depending on what type of file you want \texttt{java} to find in a given directory: if you want \texttt{java} to find compiled Java classes, use the directory name; if you want \texttt{java} to find jar files, use the directory name followed by the name of the jar (or use the wildcard \texttt{*} if you want \texttt{java} to find any jar from a given directory). Finally, the order within the classpath is significant.\index{Java!classpath}


We want Java to find the fat jar `Xenon-examples-all.jar' from `build/libs'. Using paths relative to \mytilde\url{/Xenon-examples}, our classpath thus becomes \url{build/libs/Xenon-examples-all.jar}. However, if we now try to run
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon-examples
java -cp 'build/libs/Xenon-examples-all.jar' \
nl.esciencecenter.xenon.examples.files.DirectoryListing
\end{lstlisting}
% dummy $
it still does not work yet, because \url{DirectoryListing} takes exactly one input argument that defines the location (URI\index{URI}) of the directory whose contents we want to list. URIs generally consist of a \textit{scheme}\index{URI!scheme} followed by the colon character~\texttt{:}, followed by a \textit{path}\index{URI!path}\footnote{The full specification of a URI is (optional parts in brackets): \\ \texttt{scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]}}. For a local file, the scheme is \texttt{file} (or equivalently, \texttt{local}). The path is the name of the directory we want to list the contents of, such as \texttt{\$\{PWD\}} (the present working directory).

Putting all that together, we get:

\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon-examples
java -cp 'build/libs/Xenon-examples-all.jar' \
nl.esciencecenter.xenon.examples.files.DirectoryListing file:${PWD}
\end{lstlisting} % dummy $

If all goes well, you should now see the contents of the current directory as an INFO message.


\section{Setting the log level}
\label{sec:setting-the-log-level-command-line}

Xenon uses the logback\footnote{\url{http://logback.qos.ch/}}\index{logback library}\index{logger} library for much of the output. For this, developers have sprinkled the code with so-called \textit{logger}\index{logger} statements that produce messages. Each message has been annotated as an error, a warning, debugging information, or as a plain informational message. The logback library lets the user configure where each type of message should be routed. For example, warnings and informational messages may be routed to standard output, while error messages may be routed to standard error. Furthermore, it gives the user control of how each message should be formatted, for example with regard to what class produced the message, and at what line exactly. The behavior of the logger can be configured by means of a file called \url{logback.xml}\index{logback.xml@\texttt{logback.xml}}. It is located at \url{src/main/resources/}. There should not be any need for you to change \url{logback.xml} too much, but if you do, make sure to re-run \texttt{./gradlew} for your changes to take effect.

By default, \url{logback.xml} uses a logging level of \texttt{INFO}, which means that warnings, errors, and informational messages are routed to standard output, but debug messages are not visible. At some point, you may find yourself in a situation where you want to change the logging level. There's two ways you can do that: first you can change the default behavior by editing the \texttt{loglevel} line in \url{src/main/resources/logback.xml}, saving it, and re-running \texttt{./gradlew}.

\Needspace{20\baselineskip}
Secondly, you can keep the defaults as they are, but only run a specific call with altered \texttt{loglevel} settings, by using command line parameters to the \texttt{java} program\index{Java!command line parameters}. For example, you could lower the logging level from \texttt{INFO} to \texttt{DEBUG} as follows:

\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon-examples
java -Dloglevel=DEBUG -cp 'build/libs/Xenon-examples-all.jar' \
nl.esciencecenter.xenon.examples.files.DirectoryListing file:${PWD}
\end{lstlisting} % dummy $

Standard output will now include messages of the \texttt{WARN}, \texttt{ERROR}, \texttt{INFO}, and \texttt{DEBUG} level:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
time   : 16:52:38.393 (+271 ms)
thread : main
level  : DEBUG
class  : nl.esciencecenter.xenon.adaptors.ssh.SshAdaptor:179
message: Setting ssh known hosts file to: /home/daisycutter/.ssh/config

time   : 16:52:38.396 (+274 ms)
thread : main
level  : WARN
class  : nl.esciencecenter.xenon.adaptors.ssh.SshAdaptor:242
message: OpenSSH config file cannot be read.

time   : 16:52:38.412 (+290 ms)
thread : main
level  : INFO
class  : nl.esciencecenter.xenon.engine.XenonEngine:169
message: Xenon engine initialized with adaptors: [Adaptor [name=local], Ada...
\end{lstlisting}




\section{\texttt{ssh} setup}

Up till now, you've used Xenon to perform tasks on your own system (by means of Xenon's local \texttt{file} adaptor). Usually though, you'll want to use Xenon to perform tasks on remote systems, such as the Amazon cloud, the Lisa cluster computer, the Cartesius supercomputer, or perhaps just a single machine (but not your own). In order to do anything on those remote systems, you first need to connect to them. On Linux, you can use the so-called \textit{secure shell}\index{secure shell} program \texttt{ssh}\index{ssh@\texttt{ssh}}. With \texttt{ssh}, you can set up an SSH connection to a remote system. Through SSH, you can do all the things a user is allowed to do on that system (which in turn is defined by the remote system's administrator). Note that SSH connections are a crucial part of how Xenon works: without them, you can not do anything that requires remote resources.

\subsection{\texttt{ssh} to \texttt{localhost}}

SSH uses the server-client model. Normally, your system is the client, while the remote system is the server. However, let's first see if you can connect to your own system using \texttt{ssh}. Your system will thus play the part of both client and server.

The client needs to have a so-called \textit{public-private key pair}\index{public-private key pair}. The key pair can be generated according to different algorithms:
\texttt{dsa}\index{ssh-keygen@\texttt{ssh-keygen}!dsa@\texttt{dsa}},
\texttt{ecdsa}\index{ssh-keygen@\texttt{ssh-keygen}!ecdsa@\texttt{ecdsa}},
\texttt{ed25519}\index{ssh-keygen@\texttt{ssh-keygen}!ed25519@\texttt{ed25519}}, or
\texttt{rsa}\index{ssh-keygen@\texttt{ssh-keygen}!rsa@\texttt{rsa}}.
The Linux program \texttt{ssh-keygen}\index{ssh-keygen@\texttt{ssh-keygen}} implements these algorithms; we will use it to generate a public-private key pair using the \texttt{rsa} algorithm, as follows:

\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
# generate key pair using rsa algorithm
ssh-keygen -t rsa
# (press enter to accept the default file location ~/.ssh/id_rsa)
# (press enter to set the passphrase to an empty string)
# (press enter to confirm setting the passphrase to an empty string)
\end{lstlisting}

You should now have a directory \mytilde/\url{.ssh} with two files in it: \url{id_rsa},  the private part of the key pair and \url{id_rsa.pub}, the public part of the key pair. Note that the contents of \url{id_rsa} should remain a secret.

That's it for the client-side, but you still need to do some stuff on the server-side. First, install the package \texttt{openssh-server} from the Ubuntu repositories:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
# install a server
sudo apt-get install openssh-server
\end{lstlisting} % dummy $

The server-side keeps a list \mytilde/\url{.ssh/authorized_keys} of trusted identities. You have to add the identity information from \mytilde/\url{.ssh/id_rsa.pub} to it. Linux provides an easy way of doing this, as follows:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
# copy identity, type 'yes' when prompted
ssh-copy-id ${USER}@localhost
\end{lstlisting} % dummy $

On the server-side, file \mytilde/\url{.ssh/authorized_keys} should now contain the information from \mytilde/\mbox{\url{.ssh/id_rsa.pub}}.

On the client side, SSH tried to connect the current user (whose credentials are found in \mytilde/\url{.ssh/id_rsa.pub}) to the `remote' system \url{localhost}. If that was successful, there should be a new file \mytilde/\url{.ssh/known_hosts}. \url{known_hosts} is a list of machines that we have connected to previously; i.e. these are systems we trust.

The structure of \url{known_hosts} is as follows. Each line begins with the following elements:
\begin{itemize}
\item{\texttt{1} a flag. Here, it signifies that the third element (host name) is hashed using the SHA1 algorithm;}
\item{\texttt{x5PcOam9hhAjdF84++EKwodUNgQ} the (public) salt used to encrypt the host name;}
\item{\texttt{NK1rAZev7rV6JSTIdM3ymPpKlQ0}} the (hashed) host name;}
\item{key-value pairs, e.g. the key \url{ecdsa-sha2-nistp256} and its value\\ \texttt{AAAAE2V\textit{...<characters omitted>...}RpXi/rE}, representing the public key of the `remote' system which was generated when we installed \texttt{openssh-server} and which is stored at \url{/etc/ssh/ssh_host_ecdsa_key.pub}.}
\end{itemize}
Xenon uses \texttt{known\_hosts} to automatically connect to a (known) remote system, without having to ask for credentials every time.

\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
# now try to log in without entering key:
ssh ${USER}@localhost
\end{lstlisting} % dummy $
% explain what should happen


% TODO now run \texttt{./run-examples.sh}


\subsection{\texttt{ssh} to SURFsara's Lisa cluster computer}

Obviously, using \texttt{ssh} to connect to your own system is a bit silly. Normally, you'll want to connect to a physically remote system, such as the Amazon Cloud, the Cartesius supercomputer, or maybe even just a single machine. In this section, I'll explain how to connect to SURFsara's cluster computer, Lisa. Cluster computers typically have a dedicated machine (the so-called `headnode') that serves as the main entry point when connecting from outside the cluster. For Lisa, the headnode is located at \url{lisa.surfsara.nl}.

I can connect to Lisa's head node using the \texttt{ssh} command line program as follows:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
# (my account on Lisa is called jspaaks)
ssh jspaaks@lisa.surfsara.nl
\end{lstlisting}

If this is the first time you connect to the remote machine, it will generally ask if you want to add the remote machine to the list of known hosts. For example, here's what the Lisa system tells me when I try to ssh to it:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
The authenticity of host 'lisa.surfsara.nl (145.100.29.210)' can't be
established.
RSA key fingerprint is b0:69:85:a5:21:d6:43:40:bc:6c:da:e3:a2:cc:b5:8b.
Are you sure you want to continue connecting (yes/no)?
\end{lstlisting}
If I then type \texttt{yes}, it says\footnote{SURFsara publish RSA key fingerprints for their systems at \url{https://userinfo.surfsara.nl/systems/shared/ssh}. The number posted there should be the same as what you have in your terminal.}:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
Warning: Permanently added 'lisa.surfsara.nl,145.100.29.210' (RSA) to
         the list of known hosts.

                             (*@\textit{<some content omitted>}@*)
\end{lstlisting}
and asks for my password.

The result of this connection is that \url{~/.ssh/known_hosts} now includes a line for the Lisa system.










