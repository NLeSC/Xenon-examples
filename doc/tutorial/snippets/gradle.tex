\subsection{Gradle}
\index{Gradle}

In order to use the source code from the library, we need to compile it first. Compiling source code can be a repetitive task, but fortunately there are tools available that automate much of the build process. Xenon uses Gradle for building the library.

Install Gradle using
\begin{lstlisting}[style=basic,style=bash]
sudo apt-get install gradle
\end{lstlisting}




\subsubsection{How Gradle uses conventions: an example}

In this section, I'll try to demonstrate how little configuration Gradle needs in order to be able to build Java projects successfully---as long as you don't deviate from existing conventions with regard to how the code is organized.

Make a new directory, for example \texttt{\mytilde{}/tmp/hellogradle}:
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}
mkdir -p tmp/hellogradle
\end{lstlisting} %$ dummy dollar


Then \texttt{cd} into the new directory and make a new subdirectory \texttt{src/main/java} in it. \texttt{src/main/java} is the conventional place where Java source code is stored.

\needspace{5\baselineskip}
Now open a text editor and copy-paste this Java class into it:
\begin{lstlisting}[style=basic,style=Java]
package nl.esciencecenter.hellogradle;

public class HelloGradle {

    public static void main(String[] args) {
        System.out.println("Hello, Gradle");
    }

}
\end{lstlisting}
And then save the Java class as \texttt{HelloGradle.java} in the newly created \texttt{src/main/java} directory. Files containing Java source code should have filenames that end in \url{.java}\index{Java!file extension!source code}\index{Java!file extension!.java@\texttt{.java}}.

Now let's make the simplest Gradle build file\index{Gradle!build file}. Open a new text editor and copy-paste this into it:
\begin{lstlisting}[style=basic,style=bash]
apply plugin: 'java'
\end{lstlisting}
Then save as \texttt{build.gradle}\index{Gradle!build.gradle@\texttt{build.gradle}} (the default name for Gradle build files) in the \texttt{\mytilde{}/tmp/hellogradle} directory. At this point, \texttt{\mytilde{}/tmp/hellogradle} should contain this:
\begin{lstlisting}[style=basic,style=bash]
build.gradle
src
src/main
src/main/java
src/main/java/HelloGradle.java
\end{lstlisting}

The \texttt{apply plugin}\index{Gradle!apply plugin@\texttt{apply plugin}} line in \texttt{build.gradle} tells Gradle to use the Java plugin for Gradle\index{Gradle!Java plugin}. The Java plugin defines a number of build tasks typical for a Java project. It also specifies the default locations for the project's Java source code (\texttt{src/main/java}), the compiled Java classes (\texttt{build/classes}), the documentation (\texttt{build/docs/javadoc}), as well as some other things that we'll check out later, such as unit testing and integration testing. You can find the details online at \url{https://docs.gradle.org/current/userguide/java_plugin.html}.

Gradle can tell you what tasks it knows about. Try running
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
gradle --build-file build.gradle tasks
\end{lstlisting} %$ (dummy dollar)
The \texttt{--build-file} option is used to specify which file to use as input to gradle; its short version is \texttt{-b}. This will give you the default tasks that Gradle knows about, such as \texttt{help} and \texttt{properties}. Note that \texttt{tasks} itself is a task, and so it is listed along with the other tasks. Additionally, it will list any tasks that are defined in \texttt{build.gradle}. Note that this includes any tasks which are defined implicitly (for example by \texttt{apply plugin} lines). To get a little more information on each task's dependencies, you can add the \texttt{--all} option as follows:
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
gradle --build-file build.gradle tasks --all
\end{lstlisting} %$ (dummy dollar)

In the output, there should be a task called \texttt{classes}, which compiles the (main) source code. The task \texttt{classes} is added by the Java plugin. Let's build our \url{src/main/java/HelloGradle.java} and see what that gives us. Run:
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
gradle --build-file build.gradle classes
\end{lstlisting} %$ dummy dollar
Afterwards, the directory should contain the following files and directories:
\begin{lstlisting}[style=basic,style=bash]
build
build/classes
build/classes/main
build/classes/main/nl
build/classes/main/nl/esciencecenter
build/classes/main/nl/esciencecenter/hellogradle
build/classes/main/nl/esciencecenter/hellogradle/HelloGradle.class
build/dependency-cache
build.gradle
src
src/main
src/main/java
src/main/java/HelloGradle.java
\end{lstlisting}
As you can see, Gradle generated a directory \texttt{build} and put all the things it built in it. It created a subdirectory \texttt{classes}, containing yet another subdirectory \texttt{main}, since that is the name of the so-called \mbox{`sourceSet'}\index{sourceSet} (a collection of source code files that belong together conceptually). Inside \texttt{main}, there are nested subdirectories for each part of the package name \url{nl.esciencecenter.hellogradle}. Finally, there is the compiled Java class \texttt{HelloGradle.class}. Note that files containing compiled Java code should have filenames that end in \url{.class}\index{Java!file extension!compiled}\index{Java!file extension!.class@\texttt{.class}}.
% TODO add a line about dependency-cache

Let's see if the compile worked. Run
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
java -classpath build/classes/main nl.esciencecenter.hellogradle.HelloGradle
\end{lstlisting} %$ (dummy dollar to fix editor highlighting)
The \texttt{-classpath} option tells Java it should look in \url{build/classes/main} for compiled Java classes (its short option name is \texttt{-cp}). The last argument, \url{nl.esciencecenter.hellogradle.HelloGradle} is the fully qualified name of the class we want to run. If everything worked, you should see the `Hello Gradle' greeting.

\vspace{2em}
\textit{Javadoc}
\index{Javadoc}\index{Java!Javadoc}

Java comes with a neat system of automatically documenting source code, called `Javadoc'. Javadoc is able to parse the Java source code, analyzing its structure for things like class hierarchy, public interfaces, public class methods, constructors, etc. Javadoc then generates the corresponding documentation automatically. The great advantage of generating the documentation in an automated way \textit{from the source code} is that the documentation is always up to date with how the code works.

Thanks to the Java plugin, Gradle knows how to generate Javadoc (if you run \texttt{gradle --build-file build.gradle tasks} again, you'll see a task \texttt{javadoc}, which as the name suggests, generates Javadoc documentation. You can run the \texttt{javadoc} task in the same way as you run any other task:
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
gradle --build-file build.gradle javadoc
\end{lstlisting} %$ (dummy dollar to fix editor highlighting)

The \texttt{build} directory should now have a few new items:
\begin{lstlisting}[style=basic,style=bash]
build
build/docs
build/docs/javadoc
build/docs/javadoc/nl
build/docs/javadoc/nl/esciencecenter
build/docs/javadoc/nl/esciencecenter/hellogradle
build/docs/javadoc/nl/esciencecenter/hellogradle/package-summary.html
build/docs/javadoc/nl/esciencecenter/hellogradle/HelloGradle.html
build/docs/javadoc/nl/esciencecenter/hellogradle/package-frame.html
build/docs/javadoc/nl/esciencecenter/hellogradle/package-tree.html
build/docs/javadoc/deprecated-list.html
build/docs/javadoc/constant-values.html
build/docs/javadoc/allclasses-noframe.html
build/docs/javadoc/overview-tree.html
build/docs/javadoc/index.html
build/docs/javadoc/help-doc.html
build/docs/javadoc/index-all.html
build/docs/javadoc/stylesheet.css
build/docs/javadoc/resources
build/docs/javadoc/resources/background.gif
build/docs/javadoc/resources/tab.gif
build/docs/javadoc/resources/titlebar_end.gif
build/docs/javadoc/resources/titlebar.gif
build/docs/javadoc/allclasses-frame.html
build/docs/javadoc/package-list
build/tmp
build/tmp/javadoc
build/tmp/javadoc/javadoc.options
build/classes
build/classes/main
build/classes/main/nl
build/classes/main/nl/esciencecenter
build/classes/main/nl/esciencecenter/hellogradle
build/classes/main/nl/esciencecenter/hellogradle/HelloGradle.class
build/dependency-cache
build.gradle
src
src/main
src/main/java
src/main/java/HelloGradle.java
\end{lstlisting}

You can use any web browser to navigate through the Javadoc documentation (\url{build/docs/javadoc/index.html} is probably the best starting point).

Gradle also defines a task to clean up the directory, such that you only have the bare essentials. This task is called \texttt{clean} and can be run with
\begin{lstlisting}[style=basic,style=bash]
gradle --build-file build.gradle clean
\end{lstlisting}


Note that in order to generate the documentation, the source needed to be compiled first. The task \texttt{javadoc} is said to \textit{depend on} the task \texttt{classes}. You can check that this is indeed the case by:
\begin{lstlisting}[style=basic,style=bash]
gradle --build-file build.gradle javadoc
\end{lstlisting}
This should generate \url{build/docs/javadoc} as before, but only after generating \url{build/classes} first.


So far, we've been explicitly specifying what build file Gradle should use through \texttt{gradle}'s \url{--build-file} option. However, as long as you are using the default build file (\texttt{build.gradle}), there's no need to be explicit about that---you can just run \texttt{gradle} followed by the name of the task, e.g.:
\begin{lstlisting}[style=basic,style=bash]
gradle javadoc
\end{lstlisting}

While Javadoc's automated documentation generation is helpful when it comes to the \textit{how} of the Java code, it can provide little in terms of the \textit{why} (or the \textit{why like this}). The solution for that particular problem necessarily requires input from the programmer. That is, the programmer can clarify his/her Java code by including Javadoc directives (\textit{tags}\index{Javadoc!tags}\index{Java!Javadoc!tags}), which can help explain the meaning of input arguments, variables, methods, classes, and so forth. The most common tags are listed in Table~\ref{tab:javadoc-tags}.


\begin{table}[!ht]
\vspace{1em}
\caption{Commonly used Javadoc tags.\label{tab:javadoc-tags}}
\begin{tabular}{lp{10cm}}
\vspace{0.5em}
\textbf{Tag name}    & \textbf{What the tag does}                                 \\
\texttt{@author}     & Specifies the author(s).                                   \\
\texttt{@version}    & Specifies the version.                                     \\
\texttt{@param}      & Describes a method parameter.                              \\
\texttt{@return}     & Describes the (meaning of the) returned value.             \\
\texttt{@throws}     & Describes what exceptions are thrown by this method.       \\
\texttt{@see}        & Provides a link to another element of the documentation.   \\
\texttt{@link}       & References a place in the javadoc.                         \\
\texttt{@deprecated} & Advises the user not to use a program element anymore, and ideally specifies what to use instead.     \\
\texttt{@since}      & Specifies when certain functionality was first introduced. \\
\end{tabular}
\end{table}

Note that by convention the tags appear in this order, and that Javadoc tags are lowercase.

Personally, I think \texttt{@author} is probably best avoided---if you want to know who contributed what, ask the version management system. For example, if you have a file \url{UnknownPropertyException.java} and you use \texttt{git} for version management, entering \texttt{git blame UnknownPropertyException.java}\index{Git!git blame@\texttt{git blame}} at the command line will give you a line-by-line overview of who commited what, when. Online code repositories such as Github typically also provide this capability in the form of a \textit{blame button}.
%Similarly, \texttt{@version} and \texttt{@since} are also best avoided, since the notion of versions is a little bit outdated or at least inconsistent with how Git works.
You may use \texttt{@author unascribed} if you do not want to, or cannot specify the author.

As a small example, update \url{HelloGradle.java} with a Javadoc comment, explaining what this class does, as follows:
\begin{lstlisting}[style=basic,style=bash]
package nl.esciencecenter.hellogradle;

/**
 *  This is a short one-line description of the class.
 *  <p>
 *  The Javadoc comment block appears just before the class
 *  it describes.
 *  </p>
 *  <p>
 *  You could use another paragraph to explain more stuff.
 *  </p>
 *
 *  @author      Firs T. Author
 *  @author      Secon D. Author
 *  @version     1.0, 9-Sept-2015
 *  @deprecated  As of release 1.3, replaced
 *               by {@link nl.esciencecenter.ByeGradle}
 */
public class HelloGradle {

    /**
    * 'main' is the only method.
    */
    public static void main(String[] args) {
        System.out.println("Hello, Gradle");
    }

}
\end{lstlisting}

Now run \texttt{gradle javadoc} again and check how that changed \url{build/docs/javadoc/index.html}.

\needspace{5\baselineskip}
Note that Javadoc expects the commenting style to be exactly like this:
\begin{lstlisting}[style=basic,style=bash]
/**  <- javadoc opening tag
 *  (any number of lines like this line)
 */  <- javadoc closing tags
\end{lstlisting}

% TODO add gradle eclipse


\subsubsection{The Gradle wrapper}
% TODO gradlew see https://spring.io/guides/gs/gradle/

% TODO what is the gradle wrapper

So far, we've been calling the \texttt{gradle} executable directly. There is, however, a better way of starting a Gradle build, namely by using the so-called `Gradle wrapper'\index{Gradle!wrapper}. The Gradle wrapper consists of a shell script (\url{gradlew}), a configuration file (\url{gradle/wrapper/gradle-wrapper.properties}), and some compiled Java code bundled into a Java archive (\url{gradle/wrapper/gradle-wrapper.jar}).

The Gradle wrapper is the preferred way of starting a Gradle build. This is because using \texttt{./gradlew}\index{Gradle!gradlew@\texttt{gradlew}} offers a couple of advantages over using \texttt{gradle}\index{Gradle!gradle@\texttt{gradle}}.
%
Firstly, users don't need to install Gradle in order to build the software. This is particularly convenient when  building the software on machines that are not owned or maintained by the user, as is typically the case during \textit{continuous integration testing}\index{continuous integration testing} using software such as Jenkins\index{Jenkins} or Travis\index{Travis}; we'll take a look at testing later.
%
Secondly, using the Gradle wrapper gives you the option of running a Gradle version which is more up-to-date than what's available in the operating system's software repositories. For example, my Lubuntu 14.10 comes with Gradle version 1.4, while Gradle is currently at version 2.7.
%
Thirdly, since the Gradle wrapper files are checked into the version control system, they become part of the software. This ensures that software users are running the exact same build setup as are the software developers, which improves the robustness of the software when everything is running smoothly, and improves reproducability when bugs occur.
% TODO explain first-time plugin download and where those plugins are stored
% TODO clean caches: rm ~/.m2 (maven stuff) and ~/.gradle/caches (gradle stuff)

