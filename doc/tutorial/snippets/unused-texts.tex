\chapter{Unused texts}





\section{Docker}
\index{Docker}
\index{Docker!installing}

Later on in this document, we will take a closer look at continuous integration testing\index{continuous integration testing}. Usually, setting up a testing environment\index{testing!environment} is reasonably easy, but for Xenon it's a little more complicated. This is because the Xenon library is about connecting to remote systems, but in a testing environment, such remote systems do not exist---there's only the test machine. So, in order to run Xenon tests, we need to set up an environment in which a \textit{virtual} remote system\index{testing!virtual remote system} is used. Multiple virtual remote systems may in actual fact run on one \textit{physical} machine. For now, let's just install the Docker\footnote{The remainder of this section is based on: \url{https://docs.docker.com/engine/installation/ubuntulinux/}} software that we'll use to set up virtual remote systems. Note that Docker needs a 64-bit host system. Also, it needs a minimum kernel version of 3.10 (again, on the host).

\Needspace{4\baselineskip}
Check your kernel version with:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
uname -r
\end{lstlisting}
Mine is \texttt{3.13.0-67-generic}.

The Ubuntu repositories contain an older version of Docker, which you should not use. Instead, use the newer version from Docker's own PPA\index{Docker!PPA}.

\Needspace{4\baselineskip}
First check if you have the older version by:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
docker -v
\end{lstlisting}
Mine says:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
Docker version 1.9.0, build 76d6bc9
\end{lstlisting}

If your version is lower, go ahead and uninstall as follows. First find out where your Docker program lives with:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
which docker
\end{lstlisting}

\Needspace{4\baselineskip}
and then find out which package your Docker is a part of with:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
dpkg -S `which docker`
\end{lstlisting}

If you already had Docker installed, then the package name is likely either \texttt{docker.io}\index{Docker!docker.io@\texttt{docker.io}} or \texttt{lxc-docker}\index{Docker!lxc-docker@\texttt{lxc-docker}}. Either way uninstall the entire package, including its settings with
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo apt-get remove --purge docker.io
\end{lstlisting}
or
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo apt-get remove --purge lxc-docker*
\end{lstlisting}

We will use software from a third-party repository, \url{https://apt.dockerproject.org}\index{Docker!PPA}. For this, we'll need to add the new repository's PGP key\index{Docker!PGP key} to our installation as follows:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo apt-key adv --keyserver hkp://pgp.mit.edu:80 \
--recv-keys 58118E89F3A912897C070ADBF76221572C52609D
\end{lstlisting}

The details of the next step vary depending on the operating system you are using, so let's first check which version you are running:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
lsb_release -dc
\end{lstlisting}
Make a note of your distribution's codename for the next step (mine is \texttt{trusty}).

Open or create the file \url{/etc/apt/sources.list.d/docker.list} in an editor such as nano, gedit, leafpad, etc. I'm using nano:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo nano /etc/apt/sources.list.d/docker.list
\end{lstlisting}

\Needspace{6\baselineskip}
Delete any existing entries in \url{/etc/apt/sources.list.d/docker.list}, then add one of the following options
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
deb https://apt.dockerproject.org/repo ubuntu-precise main
deb https://apt.dockerproject.org/repo ubuntu-trusty main
deb https://apt.dockerproject.org/repo ubuntu-vivid main
deb https://apt.dockerproject.org/repo ubuntu-wily main
\end{lstlisting}
(I chose the second because I'm on trusty).

Next, save and close \url{/etc/apt/sources.list.d/docker.list}.

Now that we have added Docker's PPA\index{Docker!PPA} to the list of software sources, we need to update the list with the package information as follows:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo apt-get update
\end{lstlisting}

Check if your are now using the right docker\index{Docker!docker-engine@\texttt{docker-engine}}:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
apt-cache policy docker-engine
\end{lstlisting}
Mine says:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
docker-engine:
Installed: 1.9.0-0~trusty
Candidate: 1.9.0-0~trusty
Version table:
***1.9.0-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
     100 /var/lib/dpkg/status
   1.8.3-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
   1.8.2-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
   1.8.1-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
   1.8.0-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
   1.7.1-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
   1.7.0-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
   1.6.2-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
   1.6.1-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
   1.6.0-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
   1.5.0-0~trusty 0
     500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages
\end{lstlisting}

Now for the actual install. If your Ubuntu version is Ubuntu Wily 15.10, Ubuntu Vivid 15.04, or Ubuntu Trusty 14.04 (LTS), you're in luck, as these OS'es have everything you'll need already. If you're not on one of these Ubuntu versions, refer to \url{https://docs.docker.com/engine/installation/ubuntulinux/} for instructions on installing some additional packages before proceeding with the next step.

Install Docker with\index{Docker!installing}:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo apt-get install docker-engine
\end{lstlisting}

\Needspace{4\baselineskip}
The Docker service should have started; if for some reason it hasn't, you can start it manually by\index{Docker!start service}:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo service docker start
\end{lstlisting}

Now let's try a small example to see if Docker works\index{Docker!hello world}:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo docker run hello-world
\end{lstlisting}

This command downloads a test image \texttt{hello-world} from DockerHub\index{Docker!DockerHub}, an external repository for storing Docker images\index{Docker!image}. Just to be clear, an `image' in this context refers to an image of an operating system---it has nothing to do with a picture.

% TODO add what is a container
When the container runs, it prints an informational message. Then, it exits.

You can check where docker images are stored by\index{Docker!docker info@\texttt{docker info}}:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
docker info
\end{lstlisting}
Mine are stored under \url{/var/lib/docker}; whatever the location, make sure you have enough disk space there, as Docker will download any new containers to that location.

The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user \texttt{root} and other users can access it with \texttt{sudo}. For this reason, the Docker daemon always runs as the \texttt{root} user.

To avoid having to use \texttt{sudo} when you use the \texttt{docker} command, we will create a Unix group called \texttt{docker} and add users to it. When the Docker daemon starts, it makes the ownership of the Unix socket read/writable by the \texttt{docker} group.

Add yourself to the \texttt{docker} group\index{Docker!the docker group@the \texttt{docker} group} with:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo usermod -G docker -a <name-of-user>
\end{lstlisting}
Log out and back in.

We will use multiple Docker containers simultanenously. To coordinate how individual Docker containers talk to each other, we need a tool called \texttt{docker-compose}\footnote{For more information on installation, see: \url{https://docs.docker.com/compose/install/}}\index{Docker!docker-compose@\texttt{docker-compose}}. It uses
a so-called compose file\index{Docker!compose file} to configure an container's services. Xenon's compose file is \url{docker-compose.yml} located in \url{src/integrationTest/docker/}.

To install the \texttt{docker-compose} program, first check \url{https://github.com/docker/compose/releases} to see what the latest stable version of \texttt{docker-compose} is. This determines the \texttt{VERSION\_NUM} in the command below. Mine is \texttt{1.5.0}.

\Needspace{6\baselineskip}
Download \texttt{docker-compose}\index{Docker!docker-compose@\texttt{docker-compose}} using \texttt{curl} form the terminal:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd (*@\mytilde@*)
curl -L https://github.com/docker/compose/releases/downlo\
ad/VERSION_NUM/docker-compose-`uname -s`-`uname -m` > docker-compose
\end{lstlisting}

Then move the downloaded file into the right directory on your system with:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd (*@\mytilde@*)
sudo mv docker-compose /usr/local/bin/
\end{lstlisting}

Apply executable permissions to the binary:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
sudo chmod +x /usr/local/bin/docker-compose
\end{lstlisting}

And verify that it worked:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
docker-compose --version
\end{lstlisting}
Mine says:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
docker-compose version: 1.5.0
\end{lstlisting}

That's it for now, we will get back to Docker in Section~\ref{sec:testing}:~\nameref{sec:testing}.










\section{Gradle}
\index{Gradle}

In order to use the source code from the library, we need to compile it first. Compiling source code can be a repetitive task, but fortunately there are tools available that automate much of the build process. Xenon uses Gradle for building the library.

Install Gradle using
\begin{lstlisting}[style=basic,style=bash]
sudo apt-get install gradle
\end{lstlisting}




\subsubsection{How Gradle uses conventions: an example}

In this section, I'll try to demonstrate how little configuration Gradle needs in order to be able to build Java projects successfully---as long as you don't deviate from existing conventions with regard to how the code is organized.

Make a new directory, for example \texttt{\mytilde{}/tmp/hellogradle}:
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}
mkdir -p tmp/hellogradle
\end{lstlisting} %$ dummy dollar


Then \texttt{cd} into the new directory and make a new subdirectory \texttt{src/main/java} in it. \texttt{src/main/java} is the conventional place where Java source code is stored.

\needspace{5\baselineskip}
Now open a text editor and copy-paste this Java class into it:
\begin{lstlisting}[style=basic,style=Java]
package nl.esciencecenter.hellogradle;

public class HelloGradle {

    public static void main(String[] args) {
        System.out.println("Hello, Gradle");
    }

}
\end{lstlisting}
And then save the Java class as \texttt{HelloGradle.java} in the newly created \texttt{src/main/java} directory. Files containing Java source code should have filenames that end in \url{.java}\index{Java!file extension!source code}\index{Java!file extension!.java@\texttt{.java}}.

Now let's make the simplest Gradle build file\index{Gradle!build file}. Open a new text editor and copy-paste this into it:
\begin{lstlisting}[style=basic,style=bash]
apply plugin: 'java'
\end{lstlisting}
Then save as \texttt{build.gradle}\index{Gradle!build.gradle@\texttt{build.gradle}} (the default name for Gradle build files) in the \texttt{\mytilde{}/tmp/hellogradle} directory. At this point, \texttt{\mytilde{}/tmp/hellogradle} should contain this:
\begin{lstlisting}[style=basic,style=bash]
build.gradle
src
src/main
src/main/java
src/main/java/HelloGradle.java
\end{lstlisting}

The \texttt{apply plugin}\index{Gradle!apply plugin@\texttt{apply plugin}} line in \texttt{build.gradle} tells Gradle to use the Java plugin for Gradle\index{Gradle!Java plugin}. The Java plugin defines a number of build tasks typical for a Java project. It also specifies the default locations for the project's Java source code (\texttt{src/main/java}), the compiled Java classes (\texttt{build/classes}), the documentation (\texttt{build/docs/javadoc}), as well as some other things that we'll check out later, such as unit testing and integration testing. You can find the details online at \url{https://docs.gradle.org/current/userguide/java_plugin.html}.

Gradle can tell you what tasks it knows about. Try running
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
gradle --build-file build.gradle tasks
\end{lstlisting} %$ (dummy dollar)
The \texttt{--build-file} option is used to specify which file to use as input to gradle; its short version is \texttt{-b}. This will give you the default tasks that Gradle knows about, such as \texttt{help} and \texttt{properties}. Note that \texttt{tasks} itself is a task, and so it is listed along with the other tasks. Additionally, it will list any tasks that are defined in \texttt{build.gradle}. Note that this includes any tasks which are defined implicitly (for example by \texttt{apply plugin} lines). To get a little more information on each task's dependencies, you can add the \texttt{--all} option as follows:
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
gradle --build-file build.gradle tasks --all
\end{lstlisting} %$ (dummy dollar)

In the output, there should be a task called \texttt{classes}, which compiles the (main) source code. The task \texttt{classes} is added by the Java plugin. Let's build our \url{src/main/java/HelloGradle.java} and see what that gives us. Run:
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
gradle --build-file build.gradle classes
\end{lstlisting} %$ dummy dollar
Afterwards, the directory should contain the following files and directories:
\begin{lstlisting}[style=basic,style=bash]
build
build/classes
build/classes/main
build/classes/main/nl
build/classes/main/nl/esciencecenter
build/classes/main/nl/esciencecenter/hellogradle
build/classes/main/nl/esciencecenter/hellogradle/HelloGradle.class
build/dependency-cache
build.gradle
src
src/main
src/main/java
src/main/java/HelloGradle.java
\end{lstlisting}
As you can see, Gradle generated a directory \texttt{build} and put all the things it built in it. It created a subdirectory \texttt{classes}, containing yet another subdirectory \texttt{main}, since that is the name of the so-called \mbox{`sourceSet'}\index{sourceSet} (a collection of source code files that belong together conceptually). Inside \texttt{main}, there are nested subdirectories for each part of the package name \url{nl.esciencecenter.hellogradle}. Finally, there is the compiled Java class \texttt{HelloGradle.class}. Note that files containing compiled Java code should have filenames that end in \url{.class}\index{Java!file extension!compiled}\index{Java!file extension!.class@\texttt{.class}}.
% TODO add a line about dependency-cache

Let's see if the compile worked. Run
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
java -classpath build/classes/main nl.esciencecenter.hellogradle.HelloGradle
\end{lstlisting} %$ (dummy dollar to fix editor highlighting)
The \texttt{-classpath} option tells Java it should look in \url{build/classes/main} for compiled Java classes (its short option name is \texttt{-cp}). The last argument, \url{nl.esciencecenter.hellogradle.HelloGradle} is the fully qualified name of the class we want to run. If everything worked, you should see the `Hello Gradle' greeting.

\vspace{2em}
\textit{Javadoc}
\index{Javadoc}\index{Java!Javadoc}

Java comes with a neat system of automatically documenting source code, called `Javadoc'. Javadoc is able to parse the Java source code, analyzing its structure for things like class hierarchy, public interfaces, public class methods, constructors, etc. Javadoc then generates the corresponding documentation automatically. The great advantage of generating the documentation in an automated way \textit{from the source code} is that the documentation is always up to date with how the code works.

Thanks to the Java plugin, Gradle knows how to generate Javadoc (if you run \texttt{gradle --build-file build.gradle tasks} again, you'll see a task \texttt{javadoc}, which as the name suggests, generates Javadoc documentation. You can run the \texttt{javadoc} task in the same way as you run any other task:
\begin{lstlisting}[style=basic,style=bash]
cd ${HOME}/tmp/hellogradle
gradle --build-file build.gradle javadoc
\end{lstlisting} %$ (dummy dollar to fix editor highlighting)

The \texttt{build} directory should now have a few new items:
\begin{lstlisting}[style=basic,style=bash]
build
build/docs
build/docs/javadoc
build/docs/javadoc/nl
build/docs/javadoc/nl/esciencecenter
build/docs/javadoc/nl/esciencecenter/hellogradle
build/docs/javadoc/nl/esciencecenter/hellogradle/package-summary.html
build/docs/javadoc/nl/esciencecenter/hellogradle/HelloGradle.html
build/docs/javadoc/nl/esciencecenter/hellogradle/package-frame.html
build/docs/javadoc/nl/esciencecenter/hellogradle/package-tree.html
build/docs/javadoc/deprecated-list.html
build/docs/javadoc/constant-values.html
build/docs/javadoc/allclasses-noframe.html
build/docs/javadoc/overview-tree.html
build/docs/javadoc/index.html
build/docs/javadoc/help-doc.html
build/docs/javadoc/index-all.html
build/docs/javadoc/stylesheet.css
build/docs/javadoc/resources
build/docs/javadoc/resources/background.gif
build/docs/javadoc/resources/tab.gif
build/docs/javadoc/resources/titlebar_end.gif
build/docs/javadoc/resources/titlebar.gif
build/docs/javadoc/allclasses-frame.html
build/docs/javadoc/package-list
build/tmp
build/tmp/javadoc
build/tmp/javadoc/javadoc.options
build/classes
build/classes/main
build/classes/main/nl
build/classes/main/nl/esciencecenter
build/classes/main/nl/esciencecenter/hellogradle
build/classes/main/nl/esciencecenter/hellogradle/HelloGradle.class
build/dependency-cache
build.gradle
src
src/main
src/main/java
src/main/java/HelloGradle.java
\end{lstlisting}

You can use any web browser to navigate through the Javadoc documentation (\url{build/docs/javadoc/index.html} is probably the best starting point).

Gradle also defines a task to clean up the directory, such that you only have the bare essentials. This task is called \texttt{clean} and can be run with
\begin{lstlisting}[style=basic,style=bash]
gradle --build-file build.gradle clean
\end{lstlisting}


Note that in order to generate the documentation, the source needed to be compiled first. The task \texttt{javadoc} is said to \textit{depend on} the task \texttt{classes}. You can check that this is indeed the case by:
\begin{lstlisting}[style=basic,style=bash]
gradle --build-file build.gradle javadoc
\end{lstlisting}
This should generate \url{build/docs/javadoc} as before, but only after generating \url{build/classes} first.


So far, we've been explicitly specifying what build file Gradle should use through \texttt{gradle}'s \url{--build-file} option. However, as long as you are using the default build file (\texttt{build.gradle}), there's no need to be explicit about that---you can just run \texttt{gradle} followed by the name of the task, e.g.:
\begin{lstlisting}[style=basic,style=bash]
gradle javadoc
\end{lstlisting}

While Javadoc's automated documentation generation is helpful when it comes to the \textit{how} of the Java code, it can provide little in terms of the \textit{why} (or the \textit{why like this}). The solution for that particular problem necessarily requires input from the programmer. That is, the programmer can clarify his/her Java code by including Javadoc directives (\textit{tags}\index{Javadoc!tags}\index{Java!Javadoc!tags}), which can help explain the meaning of input arguments, variables, methods, classes, and so forth. The most common tags are listed in Table~\ref{tab:javadoc-tags}.


\begin{table}[!ht]
\vspace{1em}
\caption{Commonly used Javadoc tags.\label{tab:javadoc-tags}}
\begin{tabular}{lp{10cm}}
\vspace{0.5em}
\textbf{Tag name}    & \textbf{What the tag does}                                 \\
\texttt{@author}     & Specifies the author(s).                                   \\
\texttt{@version}    & Specifies the version.                                     \\
\texttt{@param}      & Describes a method parameter.                              \\
\texttt{@return}     & Describes the (meaning of the) returned value.             \\
\texttt{@throws}     & Describes what exceptions are thrown by this method.       \\
\texttt{@see}        & Provides a link to another element of the documentation.   \\
\texttt{@link}       & References a place in the javadoc.                         \\
\texttt{@deprecated} & Advises the user not to use a program element anymore, and ideally specifies what to use instead.     \\
\texttt{@since}      & Specifies when certain functionality was first introduced. \\
\end{tabular}
\end{table}

Note that by convention the tags appear in this order, and that Javadoc tags are lowercase.

Personally, I think \texttt{@author} is probably best avoided---if you want to know who contributed what, ask the version management system. For example, if you have a file \url{UnknownPropertyException.java} and you use \texttt{git} for version management, entering \texttt{git blame UnknownPropertyException.java}\index{Git!git blame@\texttt{git blame}} at the command line will give you a line-by-line overview of who commited what, when. Online code repositories such as Github typically also provide this capability in the form of a \textit{blame button}.
%Similarly, \texttt{@version} and \texttt{@since} are also best avoided, since the notion of versions is a little bit outdated or at least inconsistent with how Git works.
You may use \texttt{@author unascribed} if you do not want to, or cannot specify the author.

As a small example, update \url{HelloGradle.java} with a Javadoc comment, explaining what this class does, as follows:
\begin{lstlisting}[style=basic,style=bash]
package nl.esciencecenter.hellogradle;

/**
 *  This is a short one-line description of the class.
 *  <p>
 *  The Javadoc comment block appears just before the class
 *  it describes.
 *  </p>
 *  <p>
 *  You could use another paragraph to explain more stuff.
 *  </p>
 *
 *  @author      Firs T. Author
 *  @author      Secon D. Author
 *  @version     1.0, 9-Sept-2015
 *  @deprecated  As of release 1.3, replaced
 *               by {@link nl.esciencecenter.ByeGradle}
 */
public class HelloGradle {

    /**
    * 'main' is the only method.
    */
    public static void main(String[] args) {
        System.out.println("Hello, Gradle");
    }

}
\end{lstlisting}

Now run \texttt{gradle javadoc} again and check how that changed \url{build/docs/javadoc/index.html}.

\needspace{5\baselineskip}
Note that Javadoc expects the commenting style to be exactly like this:
\begin{lstlisting}[style=basic,style=bash]
/**  <- javadoc opening tag
 *  (any number of lines like this line)
 */  <- javadoc closing tags
\end{lstlisting}

% TODO add gradle eclipse


\subsubsection{The Gradle wrapper}
% TODO gradlew see https://spring.io/guides/gs/gradle/

% TODO what is the gradle wrapper

So far, we've been calling the \texttt{gradle} executable directly. There is, however, a better way of starting a Gradle build, namely by using the so-called `Gradle wrapper'\index{Gradle!wrapper}. The Gradle wrapper consists of a shell script (\url{gradlew}), a configuration file (\url{gradle/wrapper/gradle-wrapper.properties}), and some compiled Java code bundled into a Java archive (\url{gradle/wrapper/gradle-wrapper.jar}).

The Gradle wrapper is the preferred way of starting a Gradle build. This is because using \texttt{./gradlew}\index{Gradle!gradlew@\texttt{gradlew}} offers a couple of advantages over using \texttt{gradle}\index{Gradle!gradle@\texttt{gradle}}.
%
Firstly, users don't need to install Gradle in order to build the software. This is particularly convenient when  building the software on machines that are not owned or maintained by the user, as is typically the case during \textit{continuous integration testing}\index{continuous integration testing} using software such as Jenkins\index{Jenkins} or Travis\index{Travis}; we'll take a look at testing later.
%
Secondly, using the Gradle wrapper gives you the option of running a Gradle version which is more up-to-date than what's available in the operating system's software repositories. For example, my Lubuntu 14.10 comes with Gradle version 1.4, while Gradle is currently at version 2.7.
%
Thirdly, since the Gradle wrapper files are checked into the version control system, they become part of the software. This ensures that software users are running the exact same build setup as are the software developers, which improves the robustness of the software when everything is running smoothly, and improves reproducability when bugs occur.
% TODO explain first-time plugin download and where those plugins are stored
% TODO clean caches: rm ~/.m2 (maven stuff) and ~/.gradle/caches (gradle stuff)










\subsubsection{Simple Xenon program from the command line}

Now for the actual example. The sourceSet `main'\index{Xenon!sourceSet!main@\texttt{main}} contains the source code for Xenon. It is located at \url{src/main/java}. We'll also need a second sourceSet, `examples'\index{Xenon!sourceSet!examples@\texttt{examples}}, which contains the source code for the Xenon examples. We'll need to compile both sourceSets in order to run a simple Xenon Java program.

Let's first check what tasks we have by:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon
./gradlew tasks --all
\end{lstlisting} % dummy $

Under `Build tasks', there should be an item \texttt{examplesClasses}, used for compiling the `examples' sourceSet; \texttt{examplesClasses} has a dependent task \texttt{classes}, used for compiling the `main' sourceSet.

Running
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon
./gradlew examplesClasses
\end{lstlisting} % dummy $
should give you a new directory \mytilde\url{/Xenon/build} with subdirectories \url{classes/examples} and {\url{classes/main} (as well as some other stuff).


The general syntax for running compiled Java programs from the command line\index{Java!from the command line} is as follows:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
java (*@\textit{<fully qualified classname>}@*)
\end{lstlisting}
The fully qualified classname for our example is \url{nl.esciencecenter.xenon.examples.CreatingXenon}, but if you try to run
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon
java nl.esciencecenter.xenon.examples.CreatingXenon
\end{lstlisting} % dummy $
you will get the error below:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
Error: Could not find or load main class \
nl.esciencecenter.xenon.examples.CreatingXenon
\end{lstlisting}

This is because the \url{java} executable tries to locate our class \url{nl.esciencecenter.xenon.examples.CreatingXenon}, but we haven't told \url{java} where to look for it. We can resolve that by specifying a list of one or more directories using \texttt{java}'s classpath option \texttt{-cp}\index{Java!from the command line!classpath}\index{Java!from the command line!-cp@\texttt{-cp}}. There are 3 locations that are relevant for running \url{CreatingXenon}. These are:
\begin{enumerate}
\item{the location of \url{CreatingXenon} itself:\\ \mytilde\url{/Xenon/build/classes/examples}}
\item{the location of the Xenon classes:\\ \mytilde\url{/Xenon/build/classes/main}}
\item{the location of any libraries that Xenon depends on:\\ \mytilde\url{/Xenon/lib}}
\end{enumerate}
These directories can be passed to \texttt{java} as a colon-separated list. Directory names can be relative to the current directory. Furthermore, the syntax is slightly different depending on what type of file you want \texttt{java} to find in a given directory: if you want \texttt{java} to find compiled Java classes, use the directory name; if you want \texttt{java} to find jar files, use the directory name followed by \texttt{/*}. Finally, the order within the classpath is significant.
% TODO find out about the order in java classpath

Using paths relative to \mytilde\url{/Xenon} for items (1) and (2) above, and using the \texttt{/*} addition for item (3) yields the following classpath value for our example: \url{build/classes/examples:build/classes/main:lib/*}, so the whole command becomes:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon
java -cp build/classes/examples:build/classes/main:lib/* \
nl.esciencecenter.xenon.examples.CreatingXenon
\end{lstlisting} % dummy $



Your output should look something like this:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
13:21:15.594 [Thread-0] DEBUG n.e.xenon.engine.util.CopyEngine - CopyEngin ...
13:21:15.606 [main] DEBUG n.e.xenon.engine.util.JobQueues - Creating JobQu ...
13:21:15.618 [main] DEBUG n.e.xenon.adaptors.ssh.SshAdaptor - Setting ssh  ...
13:21:15.632 [main] DEBUG n.e.xenon.adaptors.ssh.SshAdaptor - Host keys in ...
13:21:15.643 [main] DEBUG n.e.xenon.adaptors.ssh.SshAdaptor - |1|x5PcOam9h ...
13:21:15.650 [main] DEBUG n.e.xenon.adaptors.ssh.SshAdaptor -
13:21:15.650 [main] DEBUG n.e.xenon.adaptors.ssh.SshAdaptor - Setting ssh  ...
13:21:15.657 [main] WARN  n.e.xenon.adaptors.ssh.SshAdaptor - OpenSSH conf ...
java.io.FileNotFoundException: /home/daisycutter/.ssh/config (No such file or directory)
    at java.io.FileInputStream.open(Native Method) ~[na:1.7.0_79]
    at java.io.FileInputStream.<init>(FileInputStream.java:146) ~[na:1.7.0_79]
    at java.io.FileInputStream.<init>(FileInputStream.java:101) ~[na:1.7.0_79]
    at com.jcraft.jsch.Util.fromFile(Util.java:492) ~[jsch-0.1.50.jar:na]
    at com.jcraft.jsch.OpenSSHConfig.parseFile(OpenSSHConfig.java:97) ~[jsch-0.1.50.jar:na]
    at nl.esciencecenter.xenon.adaptors.ssh.SshAdaptor.setConfigFile(SshAdaptor.java:192) [main/:na]
    at nl.esciencecenter.xenon.adaptors.ssh.SshAdaptor.<init>(SshAdaptor.java:164) [main/:na]
    at nl.esciencecenter.xenon.adaptors.ssh.SshAdaptor.<init>(SshAdaptor.java:141) [main/:na]
    at nl.esciencecenter.xenon.engine.XenonEngine.loadAdaptors(XenonEngine.java:182) [main/:na]
    at nl.esciencecenter.xenon.engine.XenonEngine.<init>(XenonEngine.java:169) [main/:na]
    at nl.esciencecenter.xenon.engine.XenonEngine.newXenon(XenonEngine.java:92) [main/:na]
    at nl.esciencecenter.xenon.XenonFactory.newXenon(XenonFactory.java:57) [main/:na]
    at nl.esciencecenter.xenon.examples.CreatingXenon.main(CreatingXenon.java:39) [examples/:na]
Exception in thread "main" java.lang.NoClassDefFoundError: org/globus/tools/proxy/GridProxyModel
    at nl.esciencecenter.xenon.adaptors.gftp.GftpAdaptor.<clinit>(GftpAdaptor.java:47)
    at nl.esciencecenter.xenon.engine.XenonEngine.loadAdaptors(XenonEngine.java:187)
    at nl.esciencecenter.xenon.engine.XenonEngine.<init>(XenonEngine.java:169)
    at nl.esciencecenter.xenon.engine.XenonEngine.newXenon(XenonEngine.java:92)
    at nl.esciencecenter.xenon.XenonFactory.newXenon(XenonFactory.java:57)
    at nl.esciencecenter.xenon.examples.CreatingXenon.main(CreatingXenon.java:39)
Caused by: java.lang.ClassNotFoundException: org.globus.tools.proxy.GridProxyModel
    at java.net.URLClassLoader$1.run(URLClassLoader.java:366)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:425)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
    ... 6 more
\end{lstlisting} % dummy $ %to fix syntax highlighting
% FIXME OpenSSH config file cannot be read error










\subsubsection{Checking the connectivity}

Before we can run the \texttt{CreatingXenon} example, we first have to make sure that we have access to a remote system. You'll need an account on the remote machine. For example, I have an account \texttt{jspaaks} on SURFsara's Lisa clustercomputer. Cluster computers typically have a dedicated machine (the so-called `headnode') that serves as the main entry point when connecting from outside the cluster. For Lisa, the headnode is located at \url{lisa.surfsara.nl}.

I can connect to Lisa's head node using the \texttt{ssh} command line program as follows:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
# (my account on Lisa is called jspaaks)
ssh jspaaks@lisa.surfsara.nl
\end{lstlisting}

If this is the first time you connect to the remote machine, it will generally ask if you want to add the remote machine to the list of `known hosts'. For example, here's what the Lisa system tells me when I try to ssh to it:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
The authenticity of host 'lisa.surfsara.nl (145.100.29.210)' can't be
established.
RSA key fingerprint is b0:69:85:a5:21:d6:43:40:bc:6c:da:e3:a2:cc:b5:8b.
Are you sure you want to continue connecting (yes/no)?
\end{lstlisting}
If I then type \texttt{yes}, it says\footnote{SURFsara publish RSA key fingerprints for their systems at \url{https://userinfo.surfsara.nl/systems/shared/ssh}. The number posted there should be the same as what you have in your terminal.}:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
Warning: Permanently added 'lisa.surfsara.nl,145.100.29.210' (RSA) to
         the list of known hosts.

                             (*@\textit{<some content omitted>}@*)
\end{lstlisting}
and asks for my password.

The result of this connection is that you should now have a (hidden) directory \texttt{.ssh} in your \texttt{/home} directory, which should contain 3 files: \texttt{id\_rsa}, which contains your private RSA key(s); \texttt{id\_rsa.pub}, which contains your public RSA key(s); and \texttt{known\_hosts}, which contains a list of systems that you have successfully connected to in the past. \url{known_hosts} uses one line per known system, and each line begins with the following elements:
\begin{itemize}
\item{\texttt{1} a flag signifying that the third element (host name) is hashed using the SHA1 algorithm;}
\item{\texttt{x5PcOam9hhAjdF84++EKwodUNgQ} the (public) salt used to encrypt the host name;}
\item{\texttt{NK1rAZev7rV6JSTIdM3ymPpKlQ0}} the (hashed) host name;}
\item{key-value pairs, e.g. the RSA fingerprint of the Lisa system \url{ssh-rsa} \url{b0:69:85:a5:21:d6:43:40:bc:6c:da:e3:a2:cc:b5:8b}.}
\end{itemize}
Xenon uses \texttt{known\_hosts} to automatically connect to a (known) remote system, without having to ask for credentials every time.







\section{Gradle}

Normally, you'd build Xenon while connected to the Internet. The build tool we use is called Gradle. When  Gradle then downloads whatever additional software it needs. Gradle will first try to download such packages from MavenCentral\footnote{\url{https://repo1.maven.org/maven2}} (\index{MavenCentral}a website that hosts many common Java packages, in many different versions); if the package is not available from MavenCentral, or if the download fails for some other reason, Gradle tries a different website (Bintray\index{Bintray}\index{JCenter}\footnote{\url{https://bintray.com/bintray/jcenter}}). The \texttt{repositories} section in \texttt{build-common.gradle} lists the repositories that Gradle will try to connect to.


It is also possible to build Xenon while disconnected from the Internet, but in order for that to work, you need to have run \texttt{./gradlew} at least once before (while connected to the Internet). This ensures that the necessary Gradle plugins, as well as any libraries that Xenon is dependant on, will have been downloaded.
% NEEDS_VERIFICATION the local copy only exists if this is not the first time you build?
% NEEDS_VERIFICATION MavenCentral only for Java packages

In order to facilitate both online and offline building, we chose to divide the Gradle work over three files, located in the root of the repository:
\begin{enumerate}
\item{\texttt{build.gradle}\index{Xenon!Gradle!build.gradle@\texttt{build.gradle}} }
\item{\texttt{build-offline.gradle}} \index{Xenon!Gradle!build-offline.gradle@\texttt{build-offline.gradle}}}
\item{\texttt{build-common.gradle}} \index{Xenon!Gradle!build-common.gradle@\texttt{build-common.gradle}}}
\end{enumerate}

\texttt{build.gradle} and \texttt{build-offline.gradle} can be called directly as argument to \texttt{./gradlew} (or \texttt{gradle}, for that matter); \texttt{build-common.gradle} is not intended to be called directly (it should only get called from within either \texttt{build.gradle} or \texttt{build-offline.gradle}, through the use of \texttt{apply from}\index{Xenon!Gradle!apply from@\texttt{apply from}} lines. Deferring to \texttt{build-common.gradle} avoids duplication of any tasks that are the same, regardless of whether the build is offline or online.




In this section, we will test the software setup by running a small example, \texttt{CreatingXenon}. \texttt{CreatingXenon} establishes a connection to a remote system, does something simple, and returns.
% FIXME add better description of what CreatingXenon does

