
\subsection{Verifying the software setup}

To check if everything works, we first need to build the example from source and then run the example from the command line.

\subsubsection{Building with \texttt{gradlew}}

At this point, \mytilde/\url{Xenon-examples} only contains files directly related to the source code of the example files. However, in order to build and run the examples successfully, we'll need a few more things. Naturally, we'll need a copy of the Xenon library, but the Xenon library in turn also has dependencies that need to be resolved. Because the process of fitting together the right libraries is quite a lot of work, we have automated it. For this, we use the build automation tool\index{build automation}\index{build tool} Gradle\index{Gradle}\footnote{\url{http://gradle.org/}}. Interestingly, you do not need to install Gradle for it to work (although you do need Java). This is because the Xenon-examples repository already includes a script called \texttt{gradlew}, which will download a predefined version of the Gradle program upon execution. The advantage of using \texttt{gradlew} for this is that the resulting build setup will be exactly the same as what the developers use, thus avoiding any bugs that stem solely from build configuration differences.

The \texttt{gradlew} script can be run with arguments. For example, running
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon
./gradlew dependencies
\end{lstlisting} % dummy $
prints a list of the dependencies, and

\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
./gradlew clean
\end{lstlisting} % dummy $
cleans up the files pertaining to any previous builds.

\texttt{dependencies} and \texttt{clean} are referred to as `Gradle tasks', `build tasks' or just `tasks'\index{Gradle!tasks}. Tasks are defined in a so-called build file\index{Gradle!build file} called `build.gradle'. To get an overview of all available tasks you could read through `build.gradle', or you could simply run:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
./gradlew tasks
\end{lstlisting} % dummy $

or

\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
./gradlew tasks --all
\end{lstlisting} % dummy $

If you run \texttt{./gradlew tasks}, you'll see a line at the top that says that the default task is called \texttt{shadowJar}\index{shadowJar@\texttt{shadowJar}}\footnote{\url{https://github.com/johnrengelman/shadow}}. \texttt{shadowJar} bundles any and all dependencies into one large jar, sometimes referred to as a `fat jar'\index{fat jar}. Once you figure out what to put in it, using a fat jar makes deployment more robust against forgotten-dependency errors. Lucky for you, someone has already figured out how to make the fat jar, and has even written it down in a file that Gradle can understand. So when you run \texttt{./gradlew} (without any arguments), a lot of things will happen at once:
\begin{enumerate}
\item{the correct version of Gradle will be downloaded;}
\item{the Xenon library will be downloaded;}
\item{any dependencies that the Xenon library has will be downloaded;}
\item{all of that will then be compiled;}
\item{a fat jar will be created.}
\end{enumerate}

% TODO this is where I left off

\subsubsection{Running an example}

So at this point we have compiled the necessary Java classes; now we need to figure out how to run them.

The general syntax for running compiled Java programs from the command line\index{Java!from the command line} is as follows:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
java (*@\textit{<fully qualified classname>}@*)
\end{lstlisting}
The fully qualified classname for our example is \url{nl.esciencecenter.xenon.examples.files.DirectoryListing}, but if you try to run
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon
java nl.esciencecenter.xenon.examples.files.DirectoryListing
\end{lstlisting} % dummy $
you will get the error below:
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
Error: Could not find or load main class \
nl.esciencecenter.xenon.examples.files.DirectoryListing
\end{lstlisting}

This is because the \url{java} executable tries to locate our class \url{nl.esciencecenter.xenon.examples.files.DirectoryListing}, but we haven't told \url{java} where to look for it. We can resolve that by specifying a list of one or more directories using \texttt{java}'s classpath option \texttt{-cp}\index{Java!from the command line!classpath}\index{Java!from the command line!-cp@\texttt{-cp}}. There are 3 locations that are relevant for running \url{DirectoryListing}. These are:
\begin{enumerate}
\item{the location of \url{DirectoryListing} itself:\\ \mytilde\url{/Xenon/build/classes/examples}}
\item{the location of the Xenon classes:\\ \mytilde\url{/Xenon/build/classes/main}}
\item{the location of any libraries that Xenon depends on:\\ \mytilde\url{/Xenon/lib}}
\end{enumerate}
These directories can be passed to \texttt{java} as a colon-separated list, in which directory names can be relative to the current directory. Furthermore, the syntax is slightly different depending on what type of file you want \texttt{java} to find in a given directory: if you want \texttt{java} to find compiled Java classes, use the directory name; if you want \texttt{java} to find jar files, use the directory name followed by \texttt{/*}. Finally, the order within the classpath is significant.
% TODO find out about the order in java classpath

Using paths relative to \mytilde\url{/Xenon}, our classpath thus becomes \url{build/classes/examples:build/classes/main:lib/*}. However, if we now try to run
\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon
java -cp 'build/classes/examples:build/classes/main:lib/*' \
nl.esciencecenter.xenon.examples.files.DirectoryListing
\end{lstlisting}
% dummy $
it still does not work yet, because \url{DirectoryListing} takes exactly one input argument that defines the location (URI\index{URI}) of the directory whose contents we want to list. URIs generally consist of a \textit{scheme}\index{URI!scheme} followed by an \textit{authority}\index{URI!authority}. For a local file, the scheme is \texttt{file://}. The authority is the name of the directory we want to list the contents of, such as \texttt{\$PWD} (the present working directory).

Putting all that together, we get:

\begin{lstlisting}[style=basic,style=bash,escapeinside={(*@}{@*)}]
cd ${HOME}/Xenon
java -cp 'build/classes/examples:build/classes/main:lib/*' \
nl.esciencecenter.xenon.examples.files.DirectoryListing file://$PWD
\end{lstlisting} % dummy $

If all goes well, you should now see the contents of the current directory.


